use protofish::IntegrityType;
use quicfish::QuicUTP;
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1. Load the certificate to trust the server
    // For this example, we assume "cert.pem" exists (created by the server example)
    // If it doesn't exist, we can't verify the server.

    let cert_pem = match std::fs::read("cert.pem") {
        Ok(c) => c,
        Err(_) => {
            eprintln!("Error: cert.pem not found. Please run the server example first.");
            return Ok(());
        }
    };

    let mut cert_reader = std::io::Cursor::new(cert_pem);

    let addr: SocketAddr = "127.0.0.1:4433".parse()?;

    // 2. Connect to the server
    // "localhost" must match the name in the cert generated by the server
    println!("Connecting to {}...", addr);
    let pf_conn = quicfish::connect(addr, "localhost", &mut cert_reader).await?;
    println!("Connected!");

    // 3. Create a new stream context
    let arb = pf_conn.new_arb();

    // 4. Open a reliable stream
    let stream = arb.new_stream(IntegrityType::Reliable).await?;
    let (mut writer, mut reader) = stream.split();

    // 5. Send data
    let msg = "Hello from client!";
    println!("Sending: {}", msg);
    writer.write_all(msg.as_bytes()).await?;

    // 6. Read response
    let mut buf = vec![0u8; 1024];
    let n = reader.read(&mut buf).await?;

    println!("Received: {}", String::from_utf8_lossy(&buf[..n]));

    Ok(())
}
